### 1.指针
#### 引言：笔直大路边上的房子们
话说山滴那边海底那边有一个奇异的城市，它只有一条笔直的==**大道**==，所有的==房子==都在道路的==两边==，房子主人之间几乎没有什么联系。

主要靠的就是外卖小哥给彼此递送邮件，只有外卖小哥有所有房子的==地址==并准确发送邮件。

这说的是什么呢？说的就是计算机中的***内存***和***指针***的关系。


#### 指针

##### 指针类型问题
如果我们把内存当做一个很长的街道上两边的房子，那么指针就是这些房子的地址。

这几乎就是指针的全部解释了，当然是具体化的举例解释，在实际编程中，因指针而产生的需要注意的特性有很多，下面我们来详细说明

 首先我们先来一个无类型指针，它不指向任何地址：

```
		void* ptr = nullptr;//等效于void* ptr = NULL;或void* ptr = 0;
		实际上这里NULL是一个#define NULL 0。怎么写都没区别
```

我们在以往的编程经验中了解到，定义一个变量前必须先说明它的类型，但是在指针这里，==类型是没有意义的==，无论你设置成什么类型，指针的本质是一串整数，用以记录某变量在内存中的地址。

而设置类型，实际上是告诉计算机，“嗨，老登，我这个指针要指向一个某类型的变量，请你注意一下“

##### 指针使用问题
首先我们来说明的是，指针的初始化形式，我们知道指针实际上储存的值是==一串代表某变量在内存位置的整数==，而我们正常变量是表示具体的值，如果直接赋值明显会出问题：指针被储存不是地址的整数，而是实际要用的整数。这明显不符合我们设置指针的初衷。所以有==引用==这一概念的出现，于是实际指针初始化是这样：

```
#include <iostream>
#define log(x)     std::cout<<x<<std::endl

int main()
{
    int  var = 8;
    int* ptr;    
         ptr = &var;                 //&为引用，表示提取变量的地址
         
        *ptr = 10;
        log(var);   //打印出来10
}
```

我们发现有一个 “`*ptr = 10`” 的操作，这个操作是==解引用==，就是说，当我们想改变指针指向变量的值的时候，可以直接对指针解引用并赋值，以达到间接改变变量内容的操作。

##### 堆的操作以及延伸出来的二级指针
以上的操作是在栈里面执行的，如果我们想自己设置变量的大小和指针，那么必须在堆上有所行动了：

```
char*  buffer = new char[8];             //自定义内存
memset(buffer,0,8);                      //数组内全部植为0
char** ptr = &buffer;                    //二级指针指向一级指针的地址
delete[] buffer;                         //释放堆内存防止泄露
```

上面的例子中，我们先用一个指针指向自己创造的数组内存，并堆数组初始化为0，然后定义二级指针ptr指向一级指针buffer的地址，最后释放自己造的数组的内存防止泄露。

三级指针也是同理，这里不做过多说明。



### 引用相关问题
#### 引用不存在

引用唯一存在的地方就是你的代码里，而在实际编译中是没有引用这一变量的存在空间的。因此，在引用变量初始化时必须赋值，因为实际上它相当于是一个变量的==小名==。下面我们来看引用的形式：
```

#include <iostream>
#define log(x)     std::cout<<x<<std::endl

int main()
{
int     a  = 5;
int&   ref = a;

ref = 2;
log(a);                   //打印5
}


```
在引用赋值后，实际上对ref操作就是对a操作，也就是前文提到的给变量起的==小名==；


#### 函数中引用问题

我们知道，函数接受的参数实际上相当于变量的copy再赋值到函数对应参数中：例子如下：

```
......
int a  = 5;
int increment(int var)
{
	var++;
	return var;
}

increment(a);


//等效于：
int increment(int var)
{
	int var=a;
	var++;
	return var;
}
```
实际上改变的还是函数里的参数，而a的值并没有变化，在有些函数中我们想直接改变a的值，那就有两种方式：

方式一：
```
int a  = 5;
int increment(int* var)
{
	var++;
	return var;
}

increment(&a);
```


方式二：
```
int a  = 5;
int increment(int& var)
{
	var++;
	return var;
}

increment(a);
```

在方式一中，我们直接传递a的地址，即可直接改变a的值实现通过函数的a的递增。

在方式二中，我们直接把参数改为==引用==，如此以来，传输的形参相当于实参的小名，对形参的变化就是对实参的变化，也能实现同样的效果。




#### 一些小细节
##### tips1：
声明引用后，引用的对象就不能改变了，如下：

```
int a = 5;
int b = 8;
int& ref = a;
 ref = b;//等效于 a = b;
 log(a); //打印出来的是8;
```

想要改变只能通过指针实现，不要碰引用。

##### tip2：
引用的实现实际上是通过指针实现的，底层逻辑上说，引用还是指针，但作为语法糖来让使用