### 1.指针
#### 引言：笔直大路边上的房子们
话说山滴那边海底那边有一个奇异的城市，它只有一条笔直的==**大道**==，所有的==房子==都在道路的==两边==，房子主人之间几乎没有什么联系。

主要靠的就是外卖小哥给彼此递送邮件，只有外卖小哥有所有房子的==地址==并准确发送邮件。

这说的是什么呢？说的就是计算机中的***内存***和***指针***的关系。


#### 指针的特性

##### 指针类型问题
如果我们把内存当做一个很长的街道上两边的房子，那么指针就是这些房子的地址。

这几乎就是指针的全部解释了，当然是具体化的举例解释，在实际编程中，因指针而产生的需要注意的特性有很多，下面我们来详细说明

 首先我们先来一个无类型指针，它不指向任何地址：

```
		void* ptr = nullptr;//等效于void* ptr = NULL;或void* ptr = 0;
		实际上这里NULL是一个#define NULL 0。怎么写都没区别
```

我们在以往的编程经验中了解到，定义一个变量前必须先说明它的类型，但是在指针这里，==类型是没有意义的==，无论你设置成什么类型，指针的本质是一串整数，用以记录某变量在内存中的地址。

而设置类型，实际上是告诉计算机，“嗨，老登，我这个指针要指向一个某类型的变量，请你注意一下“

##### 指针使用问题
首先我们来说明的是，指针的初始化形式，我们知道指针实际上储存的值是==一串代表某变量在内存位置的整数==，而我们正常变量是表示具体的值，如果直接赋值明显会出问题：指针被储存不是地址的整数，而是实际要用的整数。这明显不符合我们设置指针的初衷。所以有==引用==这一概念的出现，于是实际指针初始化是这样：

```
#include <iostream>
#define log(x)     std::cout<<x<<std::endl
    int  var = 8;
    int* ptr;    
         ptr = &var;                 //&为引用，表示提取变量的地址
         
        *ptr = 10;
        log(var);   //打印出来10
```

我们发现有一个 “`*ptr = 10`” 的操作，这个操作是==解引用==，就是说，当我们想改变指针指向变量的值的时候，可以直接对指针解引用并赋值，以达到间接改变变量内容的操作。

##### 堆的操作以及延伸出来的二级指针
以上的操作是在栈里面执行的，如果我们想自己设置变量的大小和指针，那么必须在堆上有所行动了：

```
char*  buffer = new char[8];             //自定义内存
memset(buffer,0,8);                      //数组内全部植为0
char** ptr = &buffer;                    //二级指针指向一级指针的地址
delete[] buffer;                         //释放堆内存防止泄露
```

上面的例子中，我们先用一个