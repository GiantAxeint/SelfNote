
#### 在类和结构体外的情况
##### 全局情况
###### 针对单个文件的”私有可视化“
如果static某个变量或某个函数，实际上就是说这个变量或函数只会在本文件内可见和使用。

在文件被编译和链接的时候，static变量不会被链接到其他文件。

如果两个文件分别有同名的变量，编译时一定会报错，其中一个有static关键字则不会。

或者其中一个变量用extern 关键字，意思是本变量的定义要从其他文件中寻找与同一。或者说变量的公有可视化。（全局变量）

##### 局部静态情况

一般而言，一个函数中的变量在函数使用结束后会结束自己的声明周期，或者说，在栈中消除。

而局部静态变量就是为了应对需要生命周期很长，但是只在一个函数中变化的变量。

在函数中的局部静态变量，在函数生命结束后依然保存自身在内存中的储存，并且只在本函数内才会起变化，这给了特殊数据的处理方法。


#### 在类和结构体内的情况
##### static 变量的情况
下面我们采用struct来举例
```
struct Entity
{
	static int x, y;
	
	static void Print()
	{
		std::cout << x << " " << y << std::endl;
	}

};

int Entity::x;
int Entity::y;

int main()
{
	Entity e1;
	Entity e2;
	Entity::Print(e1);
	std::cin.get();
}
```
  如果我们在class或struct中static一个变量，这意味着这个变量是这种class或struct关键字的共用变量。
  
  以上图为例子，我们设置名为Entity的结构体，在Entity中设置静态变量x和y。此时我们用Entity定义e1和e2，并使用x和y变量前必须提前声明：

```
int Entity::x;
int Entity::y;
```

为什么class或结构体中的静态变量要单独声明呢？

假如这里有个小区叫翻斗花园，翻斗花园里有A,B,C,D四位业主，业主们共同商定，小区有一辆迈巴赫车为大伙共用。

在这个例子中，翻斗花园就是==class名==，A,B,C,D业主是==具体class变量名==，公用的迈巴赫就是==static变量==。

业主们不是只有公用迈巴赫这一辆车的，每一个业主都有自己的私家车，为了作区分，业主们就专门==声明==这辆车==属于翻斗花园小区==（因为是公有），而不属于具体的某个具体的业主。

因为是小区公有财产，所以直接声明是小区所有 比声明某业主所有 更方便，也更能避免财务纠纷。

static在编程中的作用也是这样，因为是class名旗下的所有具体class变量名都可以对他发生变化，因此直接声明它属于某个class名显然要更方便。

##### static方法（函数）的情况
类或结构体中的函数，实际上是带有类实例参数的，哪怕在代码中你并没有写上这些参数。

在类或结构体中写静态函数，如下图所示

```
struct Entity
{
	 int x,y;
	static void Print()
	{
		std::cout << x << " " << y << std::endl;
	}
};
```
如果我们使用这些函数，会发现编译错误。

因为==静态函数没法访问非静态变量==

原因是，静态函数没有==类实例==

我们写的每一个在类或结构体中的非静态方法总是会获得当前类的一个实例作为参数，这是类在我们看不见的地方工作的真实样子，他们通过==隐藏参数==发挥作用，但==静态方法不会获得这个隐藏参数==。

因此，如果我们想让上述Print函数能正常使用，必须给它参数，应当改写如下：
```
static void Print(Entity e)
	{
		std::cout << e.x << " " << e.y << std::endl;
	}
```
	
这样我们就能正常使用了。

btw，静态函数使用时也要声明class名，Print函数使用时应当写:

Entity::Print(e1);

如果不是静态函数的话，就写具体class变量名

e1.Print(e1);

这里的逻辑跟静态变量是一样的，函数是大家公用，就写”==小区名==“，不共用就写“==业主名==”



##### 总结
static几乎就是一个公有财产的标志，如果一个变量被冠以static的称号，那么每一个范围内的变化都会对它产生影响，而且

如果是静态变量或静态函数，要用具体的[[小区名]]做前提，声明[[公有财产]]是共同属于小区内所有业主的。

如果是非静态变量或函数，就用具体的[[业主名]]做前提，声明这个财产是属于私人业主的。