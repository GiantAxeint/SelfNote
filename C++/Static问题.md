
#### 在类和结构体外的情况
##### 全局情况
###### 针对单个文件的”私有可视化“
如果static某个变量或某个函数，实际上就是说这个变量或函数只会在本文件内可见和使用。

在文件被编译和链接的时候，static变量不会被链接到其他文件。

如果两个文件分别有同名的变量，编译时一定会报错，其中一个有static关键字则不会。

或者其中一个变量用extern 关键字，意思是本变量的定义要从其他文件中寻找与同一。或者说变量的公有可视化。（全局变量）

##### 局部静态情况

#### 在类和结构体内的情况
##### static 变量的情况
下面我们采用struct来举例
```
struct Entity
{
	static int x, y;
	
	static void Print()
	{
		std::cout << x << " " << y << std::endl;
	}

};

int Entity::x;
int Entity::y;

int main()
{
	Entity e1;
	Entity e2;
	Entity::Print(e1);
	std::cin.get();
}
```
  如果我们在class或struct中static一个变量，这意味着这个变量是这种class或struct关键字的共用变量。
  
  以上图为例子，我们设置名为Entity的结构体，在Entity中设置静态变量x和y。此时我们用Entity定义e1和e2，并使用x和y变量前必须提前声明：

```
int Entity::x;
int Entity::y;
```

为什么class或结构体中的静态变量要单独声明呢？

假如这里有个小区叫翻斗花园，翻斗花园里有A,B,C,D四栋别墅，业主们共同商定，小区有一辆迈巴赫车为大伙共用。

在这个例子中，翻斗花园就是==class名==，A,B,C,D楼是==具体class变量名==，公用的迈巴赫就是==static变量==。

业主们不是只有公用迈巴赫这一辆车的，每一个业主都有自己的私家车，为了作区分，业主们就专门==声明==这辆车==属于翻斗花园小区==（因为是公有），而不属于具体的某个具体的业主。

因为是小区公有财产，所以直接声明是小区所有 比声明某业主所有 更方便，也更能避免财务纠纷。

static在编程中的作用也是这样，因为是class名旗下的所有具体class变量名都可以对他发生变化，因此直接声明它属于某个class名显然要更方便。

##### static方法（函数）的情况
类或结构体中的函数，实际上是带有类实例参数的，哪怕在代码中你并没有写上这些参数。

在类或结构体中写静态函数，如下图所示

```
struct Entity
{
	 int x,y;
	static void Print()
	{
		std::cout << x << " " << y << std::endl;
	}
};
```
如果我们使用这些函数，会发现编译错误。

因为==静态函数没法访问非静态变量==

原因是，静态函数没有==类实例==

我们写的每一个在类或结构体中的非静态方法总是会获得当前类的一个实例作为参数，这是类在我们看不见的地方工作的真实样子，他们通过==隐藏参数==发挥作用，但==静态方法不会获得这个隐藏参数==。

因此，如果我们想让上述Print函数能正常使用，必须给它参数，应当改写如下：
```
static void Print(Entity e)
	{
		std::cout << e.x << " " << e.y << std::endl;
	}
```
	
这样我们就能正常使用了。

btw，静态函数使用时也要