
#### 在类和结构体外的情况
##### 全局情况
###### 针对单个文件的”私有可视化“
如果static某个变量或某个函数，实际上就是说这个变量或函数只会在本文件内可见和使用。

在文件被编译和链接的时候，static变量不会被链接到其他文件。

如果两个文件分别有同名的变量，编译时一定会报错，其中一个有static关键字则不会。

或者其中一个变量用extern 关键字，意思是本变量的定义要从其他文件中寻找与同一。或者说变量的公有可视化。（全局变量）

##### 局部静态情况

#### 在类和结构体内的情况
##### static 变量的情况
下面我们采用struct来举例
```
struct Entity
{
	static int x, y;
	
	static void Print()
	{
		std::cout << x << " " << y << std::endl;
	}

/*上述静态Print函数实际编译中进程如下↓*/
	/*static void Print(Entity e)
	{
		std::cout << e.x << " " << e.y << std::endl;
	}*/

};

int Entity::x;
int Entity::y;

int main()
{
	Entity e1;
	Entity e2;
	Entity::Print(e1);
	std::cin.get();
}
```
  如果我们在class或struct中static一个变量，这意味着这个变量是这种class或struct关键字的共用变量。
  
  以上图为例子，我们设置名为Entity的结构体，在Entity中设置静态变量x和y。此时我们用Entity定义e1和e2，并使用x和y变量前必须提前声明：

```
int Entity::x;
int Entity::y;
```

为什么class或结构体中的静态变量要单独声明呢？

假如这里有个小区叫翻斗花园，翻斗花园里有A,B,C,D四栋别墅，业主们共同商定，小区有一辆迈巴赫车为大伙共用。

在这个例子中，翻斗花园就是==class名==，A,B,C,D楼是==具体class变量名==，公用的迈巴赫就是==static变量==。

业主们不是只有公用迈巴赫这一辆车的，每一个业主都有自己的私家车，为了作区分，业主们就专门==声明==这辆车==属于翻斗花园小区==（因为是公有），而不属于具体的某个具体的业主。

因为是小区公有财产，所以直接声明是小区所有 比声明某业主所有 更方便，也更能避免财务纠纷。

static在编程中的作用也是这样，因为是calss名旗下的所有具体class变量名都可以对他发生变化，因此直接声明它属于某个class名显然要更方便。

##### static方法（函数）的情况
