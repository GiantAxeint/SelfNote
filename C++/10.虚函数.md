#### 目的
虚函数的目的，如[[9.继承]]中所说的问题一样，我们来看以下代码：
```
class Entity 
{
public:
	std::string GetName() { return "Entity"; }
	

};
class Play : public Entity
{
private:
	std::string m_name;
public:
	Play(std::string name) 
		:m_name(name) {};
	std::string GetName()  { return m_name; }
	
};
void Print(Entity* e)
{
	std::cout<<e->GetName()<<std::endl;
}

int main()
{
	Entity* e = new Entity();
	Play* p = new Play("Cherno");
	Print(e);
	Print(p);
	
	std::cin.get();
}

```
结果如下，我们看到，即使我们创造了Play的实例，并初始化为Cherno，打印p的相应字符串，结果出来的是“Entity”。

![[P%O`V7U{$3)WA6UJN]A7_KJ.png]]

正如我们在[[9.继承]]中所说的那样：

*是完全继承，也就是说Play继承Entity之后，==Play就相当于是Entity类==，也可以使用Entity中的函数，并继承父类的变量的占内存空间。*

Play在继承Entity类之后，实际上也就是Entity类了，在函数：
```
void Print(Entity* e)
{
	std::cout<<e->GetName()<<std::endl;
}
```

因为参数是“Entity*”，导致Play的实例p传过去，也会被当做是Entity





下面是有虚函数的类：
```
class Entity 
{
public:
	virtual std::string GetName() { return "Entity"; }
	

};
class Play : public Entity
{
private:
	std::string m_name;
public:
	Play(std::string name) 
		:m_name(name) {};
	std::string GetName() override { return m_name; }
};


int main()
{
	Entity* e = new Entity();
	Play*   p = new Play("Cherno");
	 std::cout<<e->GetName()<<std::endl;
	  std::cout<<p->GetName()<<std::endl;
	  std::cin.get();
}
```
回得到以下结果：
![[O[1M6V36HWPRT0L9_[TZA9R.png]]